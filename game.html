<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Мини-игра - Block Puzzle</title>
  <style>
    :root{
      --bg1:#0b5fa8;
      --bg2:#0aa2df;
      --cell:#163f63;
      --cell2:#1c4b73;
      --white:#ffffff;
    }

    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:linear-gradient(180deg,var(--bg1),var(--bg2));
      color:var(--white);
    }

    .wrap{
      width:min(1100px,96vw);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:24px;
      align-items:start;
      padding:24px;
    }

    .topbar{
      grid-column:1 / -1;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
    }

    .topbar .left{
      display:flex;
      align-items:center;
      gap:12px;
      font-weight:700;
    }

    .pill{
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.18);
      padding:8px 12px;
      border-radius:14px;
    }

    .btn{
      cursor:pointer;
      border:none;
      border-radius:14px;
      padding:10px 14px;
      color:var(--white);
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.18);
      font-weight:600;
    }
    .btn:hover{filter:brightness(1.08);}

    .board{
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.18);
      border-radius:18px;
      padding:18px;
      box-shadow:0 10px 30px rgba(0,0,0,.18);
    }

    .grid{
      width:100%;
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns:repeat(10,1fr);
      gap:6px;
      background:rgba(0,0,0,.12);
      padding:12px;
      border-radius:14px;
    }

    .cell{
      background:linear-gradient(180deg,var(--cell2),var(--cell));
      border:1px solid rgba(255,255,255,.06);
      border-radius:8px;
      position:relative;
      overflow:hidden;
      transition:transform .08s ease;
    }

    .cell.filled{
      border:1px solid rgba(255,255,255,.22);
    }

    .cell.filled.orange{
      background:linear-gradient(180deg,#ffb25a,#ff7b00);
    }
    .cell.filled.blue{
      background:linear-gradient(180deg,#6e7bff,#2f46ff);
    }

    .side{
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.18);
      border-radius:18px;
      padding:18px;
      box-shadow:0 10px 30px rgba(0,0,0,.18);
      display:flex;
      flex-direction:column;
      gap:14px;
      min-height:520px;
    }

    .pieces{
      display:flex;
      flex-direction:column;
      gap:14px;
      margin-top:6px;
    }

    .piece{
      width:100%;
      background:rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:grab;
      user-select:none;
      min-height:90px;
      transition:transform .08s ease, box-shadow .08s ease, outline-color .08s ease;
    }
    .piece:active{cursor:grabbing;}
    .piece.selected{
      outline: 2px solid rgba(255,255,255,.28);
      box-shadow: 0 0 0 4px rgba(0,0,0,.12) inset;
      transform: translateY(-1px);
    }

    .mini{
      display:grid;
      gap:6px;
      grid-auto-flow:row;
      justify-content:center;
      align-content:center;
    }

    .miniCell{
      width:24px;height:24px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,.18);
    }
    .miniCell.orange{
      background:linear-gradient(180deg,#ffb25a,#ff7b00);
    }
    .miniCell.blue{
      background:linear-gradient(180deg,#6e7bff,#2f46ff);
    }

    .hint{
      font-size:13px;
      opacity:.9;
      line-height:1.35;
    }

    .msg{
      margin-top:auto;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.12);
      font-size:13px;
      min-height:44px;
    }

    /* --- FX / HIGHLIGHTS --- */
    .cell.preview-ok{
      outline: 2px solid rgba(140,255,170,.75);
      box-shadow: 0 0 0 2px rgba(140,255,170,.18) inset;
    }
    .cell.preview-bad{
      outline: 2px solid rgba(255,140,140,.75);
      box-shadow: 0 0 0 2px rgba(255,140,140,.18) inset;
    }
    .cell.ghost{
      opacity:.65;
      filter:saturate(1.1);
    }
    .cell.shatter{
      animation: shatter .22s ease-out forwards;
    }
    @keyframes shatter{
      0%{ transform:scale(1); opacity:1; filter:blur(0px); }
      100%{ transform:scale(.75); opacity:0; filter:blur(1.5px); }
    }
    .cell.pop{
      animation: pop .12s ease-out;
    }
    @keyframes pop{
      0%{ transform:scale(.95); }
      100%{ transform:scale(1); }
    }

    @media (max-width: 900px){
      .wrap{grid-template-columns:1fr; }
      .side{min-height:auto;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="left">
        <div class="pill">Очки: <span id="score">0</span></div>
        <div class="pill">Линии: <span id="lines">0</span></div>
      </div>
      <div style="display:flex;gap:10px;align-items:center;">
        <a class="btn" href="index.html" style="text-decoration:none;display:inline-block;">В меню</a>
        <button class="btn" id="newGame">Новая игра</button>
      </div>
    </div>

    <div class="board">
      <div class="grid" id="grid"></div>
    </div>

    <div class="side">
      <div style="font-weight:800;font-size:18px;">Фигуры</div>
      <div class="hint">
        Выбери фигуру (клик) - наведи на поле - кликни, чтобы поставить. Можно и перетаскивать.
      </div>
      <div class="pieces" id="pieces"></div>
      <div class="msg" id="msg">Выбери фигуру и поставь её на поле.</div>
    </div>
  </div>

<script>
(() => {
  const SIZE = 10;
  const gridEl = document.getElementById('grid');
  const piecesEl = document.getElementById('pieces');
  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const msgEl = document.getElementById('msg');
  const newGameBtn = document.getElementById('newGame');

  let board = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
  let score = 0;
  let lines = 0;

  // --- Sound (WebAudio, без файлов) ---
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  function beep(type){
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    let f = 440, dur = .08, vol = .08;
    if(type==="pick"){ f=660; dur=.05; vol=.06; }
    if(type==="place"){ f=520; dur=.06; vol=.07; }
    if(type==="bad"){ f=180; dur=.10; vol=.08; }
    if(type==="clear"){ f=880; dur=.12; vol=.09; }
    if(type==="over"){ f=120; dur=.22; vol=.09; }

    osc.type = (type==="bad" || type==="over") ? "sawtooth" : "triangle";
    osc.frequency.setValueAtTime(f, now);
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(vol, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    osc.start(now);
    osc.stop(now + dur + 0.02);
  }

  window.addEventListener('pointerdown', () => {
    if(audioCtx.state === 'suspended') audioCtx.resume();
  }, {once:true});

  const SHAPES = [
    [[0,0],[1,0],[2,0],[3,0]],
    [[0,0],[1,0],[0,1],[1,1]],
    [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1]],
    [[0,0],[0,1],[0,2],[1,2],[2,2]],
    [[0,0],[1,0],[2,0],[1,1]],
    [[0,0]],
    [[0,0],[1,0],[2,0]],
    [[0,0],[1,0],[2,0],[3,0],[4,0]],
    [[0,1],[1,1],[1,0],[2,0]],
  ];
  const COLORS = ['orange','blue'];
  function rnd(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function shapeBounds(shape){
    let maxX = 0, maxY = 0;
    for(const [x,y] of shape){ if(x>maxX) maxX=x; if(y>maxY) maxY=y; }
    return {w:maxX+1, h:maxY+1};
  }

  let selectedPieceId = null;

  function makePiece(){
    return { id: crypto.randomUUID(), shape: rnd(SHAPES), color: rnd(COLORS) };
  }
  let currentPieces = [];

  function canPlace(shape, ox, oy){
    for(const [x,y] of shape){
      const px = ox + x, py = oy + y;
      if(px<0 || py<0 || px>=SIZE || py>=SIZE) return false;
      if(board[py][px]) return false;
    }
    return true;
  }
  function place(shape, ox, oy, color){
    for(const [x,y] of shape){
      board[oy+y][ox+x] = color;
    }
  }
  function getPieceById(id){
    return currentPieces.find(p => p.id === id) || null;
  }

  function clearPreviewClasses(){
  const els = gridEl.querySelectorAll('.cell.preview-ok,.cell.preview-bad,.cell.ghost,.cell.ghost-fill');
  els.forEach(el => {
    el.classList.remove('preview-ok','preview-bad','ghost','ghost-fill');
    // ВАЖНО: убираем временный цвет, если клетка по board пустая
    const x = Number(el.dataset.x);
    const y = Number(el.dataset.y);
    if (!board[y][x]) {
      el.classList.remove('filled','orange','blue');
    }
  });
}


  function applyPreview(piece, ox, oy){
    clearPreviewClasses();
    if(!piece) return false;

    const ok = canPlace(piece.shape, ox, oy);
    for(const [dx,dy] of piece.shape){
      const x = ox+dx, y = oy+dy;
      if(x<0 || y<0 || x>=SIZE || y>=SIZE) continue;
      const el = gridEl.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
      if(!el) continue;

      el.classList.add(ok ? 'preview-ok' : 'preview-bad');

      if(ok && !board[y][x]){
        el.classList.add('ghost','filled',piece.color);
      }
    }
    return ok;
  }

  function anyMovePossible(pieces){
    for(const p of pieces){
      for(let y=0;y<SIZE;y++){
        for(let x=0;x<SIZE;x++){
          if(canPlace(p.shape, x, y)) return true;
        }
      }
    }
    return false;
  }

  function renderBoard(){
    gridEl.innerHTML = '';
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.x = x;
        cell.dataset.y = y;

        const v = board[y][x];
        if(v){
          cell.classList.add('filled', v);
        }

        cell.addEventListener('pointerenter', () => {
          if(!selectedPieceId) return;
          const piece = getPieceById(selectedPieceId);
          if(!piece) return;
          applyPreview(piece, x, y);
        });

        cell.addEventListener('click', () => {
          if(!selectedPieceId) return;
          const piece = getPieceById(selectedPieceId);
          if(!piece) return;
          tryPlace(piece, x, y);
        });

        cell.addEventListener('dragover', (e) => e.preventDefault());
        cell.addEventListener('drop', (e) => {
          e.preventDefault();
          const pieceId = e.dataTransfer.getData('text/plain');
          const piece = getPieceById(pieceId);
          if(!piece) return;
          selectedPieceId = piece.id;
          tryPlace(piece, x, y);
        });

        gridEl.appendChild(cell);
      }
    }
  }

  function renderPieces(){
    piecesEl.innerHTML = '';
    currentPieces.forEach((p) => {
      const box = document.createElement('div');
      box.className = 'piece' + (p.id === selectedPieceId ? ' selected' : '');
      box.draggable = true;
      box.dataset.id = p.id;

      const {w,h} = shapeBounds(p.shape);
      const mini = document.createElement('div');
      mini.className = 'mini';
      mini.style.gridTemplateColumns = `repeat(${w}, 24px)`;

      for(let yy=0;yy<h;yy++){
        for(let xx=0;xx<w;xx++){
          const m = document.createElement('div');
          m.className = 'miniCell';
          const filled = p.shape.some(([sx,sy]) => sx===xx && sy===yy);
          if(filled) m.classList.add(p.color);
          else {
            m.style.opacity = '0.12';
            m.style.border = '1px solid rgba(255,255,255,.10)';
            m.style.background = 'transparent';
          }
          mini.appendChild(m);
        }
      }

      box.appendChild(mini);

      box.addEventListener('click', () => {
        selectedPieceId = (selectedPieceId === p.id) ? null : p.id;
        clearPreviewClasses();
        renderPieces();
        if(selectedPieceId) {
          beep("pick");
          msgEl.textContent = 'Выбрана фигура. Наведи на поле и кликни, чтобы поставить.';
        } else {
          msgEl.textContent = 'Выбор снят.';
        }
      });

      box.addEventListener('dragstart', (e) => {
        selectedPieceId = p.id;
        e.dataTransfer.setData('text/plain', p.id);
        beep("pick");
        renderPieces();
      });

      piecesEl.appendChild(box);
    });
  }

  function popPlacedCells(shape, ox, oy){
    for(const [dx,dy] of shape){
      const x = ox+dx, y = oy+dy;
      const el = gridEl.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
      if(el){
        el.classList.add('pop');
        setTimeout(() => el.classList.remove('pop'), 140);
      }
    }
  }

  function clearLinesAnimated(){
    const fullRows = [];
    const fullCols = [];

    for(let y=0;y<SIZE;y++){
      if(board[y].every(Boolean)) fullRows.push(y);
    }
    for(let x=0;x<SIZE;x++){
      let full = true;
      for(let y=0;y<SIZE;y++){
        if(!board[y][x]){ full=false; break; }
      }
      if(full) fullCols.push(x);
    }

    const cleared = fullRows.length + fullCols.length;
    if(cleared === 0) return 0;

    const toClear = new Set();
    for(const y of fullRows) for(let x=0;x<SIZE;x++) toClear.add(`${x},${y}`);
    for(const x of fullCols) for(let y=0;y<SIZE;y++) toClear.add(`${x},${y}`);

    for(const key of toClear){
      const [x,y] = key.split(',').map(Number);
      const el = gridEl.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
      if(el) el.classList.add('shatter');
    }

    setTimeout(() => {
      for(const y of fullRows){
        board[y] = Array(SIZE).fill(null);
      }
      for(const x of fullCols){
        for(let y=0;y<SIZE;y++) board[y][x] = null;
      }

      lines += cleared;
      score += cleared * 100 + (cleared-1)*50;
      linesEl.textContent = lines;
      scoreEl.textContent = score;
      msgEl.textContent = `Линии убраны: ${cleared}`;
      beep("clear");

      renderBoard();
      renderPieces();
      clearPreviewClasses();
    }, 230);

    return cleared;
  }

  function tryPlace(piece, x, y){
    clearPreviewClasses();

    if(!canPlace(piece.shape, x, y)){
      msgEl.textContent = 'Сюда не влезает. Наведи на другое место.';
      beep("bad");
      applyPreview(piece, x, y);
      return;
    }

    place(piece.shape, x, y, piece.color);

    score += piece.shape.length * 10;
    scoreEl.textContent = score;
    beep("place");

    currentPieces = currentPieces.filter(p => p.id !== piece.id);
    selectedPieceId = null;

    renderBoard();
    popPlacedCells(piece.shape, x, y);

    clearLinesAnimated();

    if(currentPieces.length === 0){
      currentPieces = [makePiece(), makePiece(), makePiece()];
      msgEl.textContent = 'Новые фигуры!';
    }

    renderPieces();

    if(!anyMovePossible(currentPieces)){
      msgEl.textContent = 'Ходов нет. Нажми "Новая игра".';
      beep("over");
    }
  }

  function reset(){
    board = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
    score = 0;
    lines = 0;
    selectedPieceId = null;
    scoreEl.textContent = '0';
    linesEl.textContent = '0';
    msgEl.textContent = 'Выбери фигуру и поставь её на поле.';
    currentPieces = [makePiece(), makePiece(), makePiece()];
    renderBoard();
    renderPieces();
    clearPreviewClasses();
  }

  gridEl.addEventListener('pointerleave', () => {
    clearPreviewClasses();
  });

  newGameBtn.addEventListener('click', reset);

  reset();
})();
</script>
</body>
</html>
